\documentclass[12pt]{article}
\usepackage[document]{ragged2e}
\usepackage{geometry, array, graphicx, wrapfig, float, amsmath, titlesec, amsmath, amsfonts, mathtools, amssymb}
\usepackage[thinlines]{easytable}
\graphicspath{ {./pics/} }
\geometry{a4paper, inner=3.5cm, outer=2.5cm, bottom=2.5cm, top=2.5cm}
\renewcommand{\baselinestretch}{1.5}
\setlength{\parskip}{1em}
\makeatletter
\def\legendre@dash#1#2{\hb@xt@#1{%
		\kern-#2\p@
		\cleaders\hbox{\kern.5\p@
			\vrule\@height.2\p@\@depth.2\p@\@width\p@
			\kern.5\p@}\hfil
		\kern-#2\p@
}}
\def\@legendre#1#2#3#4#5{\mathopen{}\left(
	\sbox\z@{$\genfrac{}{}{0pt}{#1}{#3#4}{#3#5}$}%
	\dimen@=\wd\z@
	\kern-\p@\vcenter{\box0}\kern-\dimen@\vcenter{\legendre@dash\dimen@{#2}}\kern-\p@
	\right)\mathclose{}}
\newcommand\legendre[2]{\mathchoice
	{\@legendre{0}{1}{}{#1}{#2}}
	{\@legendre{1}{.5}{\vphantom{1}}{#1}{#2}}
	{\@legendre{2}{0}{\vphantom{1}}{#1}{#2}}
	{\@legendre{3}{0}{\vphantom{1}}{#1}{#2}}
}
\def\dlegendre{\@legendre{0}{1}{}}
\def\tlegendre{\@legendre{1}{0.5}{\vphantom{1}}}
\makeatother
\begin{document}
	\newcommand{\sectionbreak}{\clearpage}
	\begin{titlepage}
		\begin{minipage}{0.36\textwidth}
			\begin{figure}[H]
				\includegraphics[scale=0.1]{elte_cimer_szines.jpg}
			\end{figure}
		\end{minipage}
		\begin{minipage}{0.60\textwidth}
			\begin{center}
				{\Large Eötvös Loránd Tudományegyetem \\
					Informatikai Kar \\
					Komputeralgebra Tanszék \\}
			\end{center}
		\end{minipage}
		\\[0.3\baselineskip]
		\noindent\makebox[\linewidth]{\rule{\textwidth}{0.5pt}}
		\vspace*{\fill}
		\centering
		\vspace*{0.5cm}
		
		\huge\bfseries
		Pszeudovéletlen sorozatok mértékei és konstrukciói		
		\vspace*{0.5cm}
		
		\vspace*{\fill}
		\begin{TAB}(r,0.5cm,0.5cm)[9pt]{cc}{cccc}
			\normalfont \normalsize \textsl{ Szerző: } & \normalfont \normalsize \textsl{ Témavezető: } \\
			\normalsize Kovács Levente & \normalsize Dr. Tóth Viktória \\
			\normalfont \normalsize programtervező informatikus BSc & \normalfont \normalsize egyetemi adjunktus \\
			\normalsize & \normalfont \normalsize Komputeralgebra Tanszék
		\end{TAB}
		\\
		\large \normalfont Budapest, 2019
	\end{titlepage}
	\renewcommand*\contentsname{Tartalomjegyzék}
	\tableofcontents
	\newpage
	\section{Bevezető}
	\subsection{Történeti betekintés}
	Véletlen sorozatok generálására sok modern területnek igénye van (pl.: statisztika, szimulációk, kriptográfia). Számítógéppel azonban nem lehetséges valódi véletlen számokat generálni, ezért pszeudovéletlen eljárásokra hagyatkozunk. Cél az, hogy olyan eljárásokat használjunk melyek statisztikailag véletlennek tűnnek, attól függetlenül, hogy egy determinisztikus rendszer generálja az eredményt.
	\par
	Az ilyen sorozatokra való igény először Gilbert Vernam munkájának következménye. 1917-ben Vernam feltalálta a one-time pad titkosítási eljárást. Az üzeneteket telegráfon bitenként továbbították, viszont az eredeti adatot valamilyen kulcs segítségével megváltoztatták (amit aztán a fogadó fél a kulcs ismeretében vissza tud fejteni). Ha le is hallgatták a küldött adatot, akkor a kulcs nélkül nem lehetett tudni, hogy mi volt az eredeti üzenet.
	\par
	1949-ben Claude Shannon, matematikus, bebizonyította a fenti eljárásról, hogyha egy jó sorozatot használunk kulcsnak, akkor az eredeti és a titkosított bitsorozat között nem lehet semmiféle összefüggést találni. Ennek következménye, hogy a Vernam-féle one-time pad eljárást nem lehet feltörni, ha megfelelő, egyszer használatos kulcsokat használunk.
	\par
	Az is igaz azonban, hogyha nem megfelelő kulcsokat használunk (pl. többször használjuk a kulcsokat), akkor a titkosítás könnyen törhető. A fő nehézség tehát a one-time pad használatánál, hogy nagy méretű véletlen bitsorozatokat kell előállítani kulcsoknak.
	\par
	Az ilyen sorozatok előállításához régen fizikai eszközöket használtak, pl. diódákat. A problémája az ilyen eszközöknek, hogy külső tényezők is befolyásolják a véletlenséget, és meghibásodás is történhet. Ezért nagyon fontos, a véletlenség vizsgálása különböző statisztikai tesztekkel, ami azonban időigényes. Emiatt jobb, hogyha "csak" pszeudovéletlen sorozatokat állítunk elő. Így elkerülhető a statisztikai tesztelés, mivel bizonyítottan jó véletlen tulajdonságokkal rendelkező sorozatot kapunk.
	\par
	A pszeudovéletlen tulajdonságok mérésével sok évtizede foglalkoznak matematikusok. Elsőként Émile Borel definiálta végtelen bináris sorozatokra a pszeudovéletlenség normalitás mértékét. Később Solomon Wolf Golomb és Donald Knuth próbálkoztak a pszeudovéletlenség matematikai fogalmának definiálására. Ennek a definíciónak alapvető gyengeségei voltak, ezért ezt ma már nem nagyon használják. Ezután Andrej Nyikolajevics Kolmogorov és Gregory John Chaitin bonyolultságelméleti irányból közelítették meg a problémát, de a gyakorlatban ezek a fogalmak nem kaptak nagy jelentőséget, mivel alkalmazásuk nem jól kivitelezhető.
	\par
	Ezen próbálkozások inspiráltak egy új, konstruktív megközelítést a pszeudovéletlenség vizsgálatára. Christian Manduit és Sárközy András megközelítése az volt, hogy léteznek olyan sorozatok, melyekről bizonyítható, hogy statisztikailag erős véletlen tulajdonságokkal rendelkeznek (más szóval: erős pszeudovéletlen tulajdonságúak), így az utólagos tesztelés elkerülhető. Ez a fajta vizsgálat az évek során egyre szélesebb körben alkalmazott.
	\subsection{A program célja}
	A programom célja, hogy a fent említett konstrukció keretén belül vizsgáljak különböző pszeudovéletlen sorozatokat. A vizsgált konstrukciókat két csoportból válogattam. Egyik kategóriába matematikai hátterű sorozatok tartoznak, melyeknek működése főként számelméleti ismereteken alapulnak. A másik csoport az iparban széles körben használt pszeudovéletlen generátorok, amik nem feltétlenül matematikai hátterűek.
	\par
	A programban lehetőség nyílik a pszeudovéletlen konstrukciók kipróbálására, és a generált sorozatok vizsgálatára a statisztikai mértékek szerint. A sorozatokat ki is próbálhatjuk a Vernam-féle one-time pad titkosítási eljárással.
	\section{Felhasználói dokumentáció}
	A program pszeudovéletlen sorozatkonstrukciók kipróbálására és a sorozatok vizsgálatára készült a statisztikai mértékekkel.
	\subsection{Rendszerkövetelmények}
	\subsection{Futattás}
	\subsection{Menürendszer}
	A menürendszer pontjainak 3 fő csoportja van, ezek:
	\begin{itemize}
		\item Alapvető funkciók: Kilépés, vissza a főmenübe
		\item Konstrukciók: A konstrukciók kipróbálása
		\item Tesztelés: Mértékek és titkosítás
	\end{itemize}
	\subsubsection{Főmenü}
	Amikor a program elindul a felhasználót a főmenü fogadja. Itt elérhető az összes megvalósított konstrukció almenüpontja és a mértékek, illetve titkosításé is.
	
	Kilépni a program jobb felső sarkában található "X" gombbal, vagy a főmenüben található "Kilépés" gombbal lehet.
	\subsection*{Konstrukciók}
	Ez a pont csak alapvető segítséget nyújt a különböző konstrukciók kipróbálásához. Részletes leírása az algoritmusoknak a fejlesztői dokumentációban találhatóak.
	\par
	\subsubsection{Legendre szimbólumos konstrukció}
	Ez a konstrukció a Legendere szimbólumon alapul, melynek véletlen tulajdonságait régóta vizsgálják.
	\par
	Szükséges paraméterek:
	\begin{enumerate}\bfseries
		\item A sorozat hossza
		\\ \normalfont{A sorozat hosszát bájtokban kell megadni, tehát az 1 bájt hosszú sorozat 8 bitet foglal magába. Bármennyi lehet.}
		\bfseries \item Prímszám
		\\ \normalfont Egy olyan prímszámra van szükségünk a konstrukcióhoz, mely legalább 16-szor nagyobb mint a sorozat hossza (bitben megadott méret esetén 2-szer nagyobb). Az is kell, hogy a 2 legyen primitív gyök modulo prím. A "Generálás" gombbal a program megkeresi a legkisebb olyan prímet mely a fenti feltételeknek megfelel. A "Következő" gombbal ugorhatunk a következő legkisebb jó prímre.
		\bfseries \item A konstrukcióhoz használt polinom fokszáma \\ \normalfont
		A fokszám nem lehet túl nagy függően a prímszámtól, de túl kicsi sem. Az alsó határ jelen megvalósításban 2-nek, a felső $5\cdot\sqrt[\leftroot{-2}\uproot{2}10]{p}$-nek lett megszabva, ahol p a használt prímszám. Polinom fokszámot generálhatunk a fenti intervallumban a "Generálás" gombbal.
		\bfseries \item A polinom \\
		\normalfont
		A konstrukció jó működéséhez szükséges, hogy olyan polinomot válasszunk, amelynek csak egyszeres gyökei vannak. Emiatt a polinomot a gyökeinek felsorolásával reprezentáljuk, ezeket a szóközzel elválasztva kell felsorolni a szövegmezőben. Lehetőség van polinom generálására is, ekkor a program legenerál egy az előző pontban megadott fokszámú polinomot.
	\end{enumerate}
	Ha fenti paramétereket megadtuk, akkor a "Sorozat generálása" gombra kattintva megkapjuk az eredményét a Legendre konstrukciónak a kapott bemenetre.
	\subsubsection{RC4 konstrukció}
	Az RC4 konstrukciót Ron Rivest fejlesztette ki az 1987-ben viszont eredetileg üzleti titok volt. 1994-ben azonban kiszivárgott az algoritmus leírása. A működése egyszerű és gyors, ezért használata széles körben elterjedt, viszont vannak rossz tulajdonságai.
	\par
	Szükséges paraméterek:
	\begin{enumerate}
		\bfseries\item A sorozat hossza \\
		\normalfont A sorozat hosszát bájtokban kell megadni. Bármennyi lehet.
		\bfseries \item A kulcs
		\\
		\normalfont A kulcs változó méretű lehet, ez alapján fog történni a generálás. Tipikusan 40-2048 bit hosszú a kulcs. Ez a megvalósítás egy szöveget vár kulcsnak, így átfogalmazva a feltételt legalább 5, maximum 256 karakter hosszú lehet a kulcs.
	\end{enumerate}
	A fenti paraméterek megadása után megtekinthetjük az RC4 konstrukció által generált sorozatot a "Sorozat generálása" gombbal.
	\section{Fejlesztői dokumentáció}
	\subsection{Konstrukciók}
	\subsubsection{Legendre konstrukció}
	\subsubsection*{Ismertető}
	\textbf{Def.}: Ha $p$ egy prímszám, és $a \in \mathbb{Z}$, akkor az $\legendre{a}{p}$ Legendre-szimbólum értéke: \par
	$$\legendre{a}{p} =
	\begin{cases*}
	1 & ha $a$ kvadratikus maradék modulo $p$ és $a \not\equiv 0\ (\textrm{mod}\ p)$ \\
	-1       & ha $a$ nem kvadratikus maradék modulo $p$\\
	0 & ha $a \equiv 0\ (\textrm{mod}\ p)$
	\end{cases*}$$
	A Legendre-szimbólum véletlenségét már régóta vizsgálták, ez volt a motiváció a konstrukció megvalósítására.
	\subsubsection*{Algoritmus}
	\begin{enumerate}
		\item Vegyünk egy olyan $p$ prímet, hogy a $2$ legyen primitív gyök modulo $p$
		\item Vegyünk egy olyan $f \in \mathbb{F}_p[x]$ polinomot, melynek csak egyszeres gyökei vannak, és foka nem túl nagy p-hez képest
		\item A ($e_0, e_1, ..., e_{k-1}$) sorozat $n$. tagja: $e_n = 
		\begin{cases*}
		\legendre{f(i)}{p} &, ha $f(i) \nmid  p$  \\
		1 &, ha $f(i) \mid p$ 
		\end{cases*}
		$
	\end{enumerate}
	\subsubsection*{Extra követelmények}
	Ha egy $n$ hosszú sorozatot szeretnénk generálni, akkor a használt $p$ prímre legyen igaz, hogy $p > 2n$. A polinom fokszáma szeretnénk, ha nem lenne túl kicsi, és a felső határt $p$-hez viszonyítva kell megadni. Jelen megvalósításban ha $k$ a polinom fokszáma, akkor legyen $2 \leq k \leq 5\cdot\sqrt[\leftroot{-2}\uproot{2}10]{p}$.
	\subsubsection{RC4 konstrukció}
	\subsubsection*{Ismertető}
	Az RC4 stream cipher algoritmus a bájt hosszúságú bitsorozatok egy permutációjának előállításával kezdődik, ami egy kulcssorozat segítségével történik. Ez a key-scheduling fázisa az algoritmusnak.
	\par
	Ez után következik a tényleges sorozat generálás. Ameddig kell a sorozatot generálni (pl. hossz alapján), addig az algoritmus lépésenként keveri a bájtok sorrendjét, és közben egy bájtnyi kimenetet generál.
	\par
	Ebben a megvalósításban a klasszikus, módosítások nélküli algoritmust valósítottam meg, hogy ez hogyan viszonyul a megvalósított mértékekhez.
	A módszernek több változata van, amik javíthatják a véletlenségét a generált sorozatnak.
	\subsubsection*{Algoritmus}
	\begin{enumerate}
		\item Töltsünk fel egy 256 elemű $S$ tömböt úgy, hogy $i$. indexére: $S[i]:=i$. 0-tól indexelünk, és gyakorlatilag az összes 8 hosszúságú bitsorozatot kell előállítani
		\item Adjunk meg egy $n$ méretű $K$ (ebben a megvalósításban egy $n$ karakterű ASCII kódolású szöveg) kulcstömböt, ahol $1 \leq n \leq 256$
		\item Ez az algoritmus key-scheduling fázisa. Legyen $i, j:=0$, majd:
			\begin{enumerate}
				\item Legyen $j:=(j+S[i]+K[i \ \textrm{mod}\ n]) \ \textrm{mod} \ 256$
				\item Cseréljük ki $S[i]$ és $S[j]$ értékét
				\item Inkrementáljuk $i$-t, ha $i < 256$, akkor ugorjunk vissza (a)-ra
			\end{enumerate}
		\item Ez a sorozatgeneráló fázis. Legyen $i, j := 0$, $n$-szer kell generálni 1 bájtnyi kimenetet, tehát ennek követésére legyen $l:=0$, majd:
		\begin{enumerate}
			\item Legyen: $i := (i+1) \ \textrm{mod} \ 256$, majd $j := (j + S[i]) \ \textrm{mod} \ 256$
			\item Cseréljük ki $S[i]$ és $S[j]$ értékét
			\item Legyen $T := S[(S[i] + S[j]) \ \textrm{mod} \ 256]$, T lesz a mostani generálási lépés 1 bájtnyi kimenete
			\item Inkrementáljuk $l$-t, ha $l < n$, akkor ugorjunk vissza (a)-ra
		\end{enumerate}
	\end{enumerate}
	\subsubsection*{Egyéb követelmények}
	Elvárjuk, hogy a kulcssorozat ne legyen túl rövid (általában 40 bit az alsó határ). Jelen megvalósításban: $n \geq 5$, vagyis legalább 5 karakter hosszú kulcs kell.
\end{document}